# 41343149

## 作業一 $Ackermann's Function$

## 解題說明

使用遞迴函式和非遞迴函式實現阿克曼函數

### $Ackermann$ 函數定義如下 :
| $A(m,n)$                 | 條件                  |
|------------------------|----------------------|
| $n + 1$                  | 當 m = 0             |
| $A(m-1, 1)$              | 當 n = 0             |
| $A(m-1, A(m, n-1))$      | 其他                 |

### 解題策略

1. 遞迴函式
   直接依照數學定義撰寫函式。每次呼叫自己時縮小問題規模，直到遇到最基本的情況 $m=0$ 。
2. 非遞迴函式
   使用堆疊模擬遞迴呼叫 每次將當前的 $m$ 推入堆疊，依條件進行回溯運算，直到堆疊清空為止

## 程式實作

遞迴函式：

```cpp
#include <iostream>
using namespace std;

// Ackermann 函式 (遞迴)
int Ackermann(int m, int n) {
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return Ackermann(m - 1, 1);
    else
        return Ackermann(m - 1, Ackermann(m, n - 1));
}

int main() {
    int m, n;
    cout << "請輸入 m 與 n ：";
    while (cin >> m >> n) {
        cout << "A(" << m << ", " << n << ") = " << Ackermann(m, n) << endl;
        cout << "請輸入 m 與 n ：";
    }
    return 0;
}
```
非遞迴涵式 :

```cpp
#include <iostream>
using namespace std;

int AckermannLoop(int m, int n) {
    const int STACK_SIZE = 100000;
    int stack[STACK_SIZE];
    int top = 0;

    stack[top++] = m;

    while (top > 0) {
        m = stack[--top];

        if (m == 0) {
            n += 1;
        }
        else if (n == 0) {
            stack[top++] = m - 1;
            n = 1;
        }
        else {
            stack[top++] = m - 1;
            stack[top++] = m;
            n -= 1;
        }
    }
    return n;
}

int main() {
    int m, n;
    cout << "請輸入 m 與 n ：";
    while (cin >> m >> n) {
        cout << "A(" << m << ", " << n << ") = " << AckermannLoop(m, n) << endl;
        cout << "請輸入 m 與 n ：";
    }
    return 0;
}
```

## 效能分析
遞迴函式:
1. 時間複雜度：當 $m$ 與 $n$　的數值較小時(例如 $m=2,n=4$ )，整體遞迴深度仍然可控制在安全範圍內;但隨著輸入增大，遞迴呼叫會迅速堆疊，導致記憶體占用成倍成長。當 $m=0,1,2$ 時，空間複雜度大約為 $O(1)$ 、 $O(2)$ 、 $O(3)$ ;若m=3，則上升至約 $O(2ⁿ)$ ；而當 $m≥4$ 時，成長速度甚至超越指數級，極容易造成系統堆疊溢位。
2. 空間複雜度：對於較小的 $m$ 值(例如 $0、1、2、3$ )，可藉由簡單的遞迴公式推得其時間複雜度分別約為 $O(1)$ 、 $O(n)$ 、 $O(2ⁿ)$ 。但當 $m$ 提升至 4 以上時，函式的執行次數呈現爆炸性增長，其增長速率遠超過一般指數級，理論上屬於超指數等級的複雜度。

非遞迴函式:
1. 時間複雜度：在非遞迴版本中，雖然以陣列模擬呼叫堆疊能避免系統層級的遞迴限制，但所需的空間量仍隨m與n的增長急劇膨脹。當 $m=3$ 時，約為 $O(n)$ ;當m=4時，則提升為 $O(2ⁿ)$ ;而若 $m≥5$ ，其空間需求甚至可達 $O(2^(2^(⋯2^n)))$ 的多層次指數規模。
2. 空間複雜度：非遞迴實作的時間成本與遞迴版本相當，因為運算邏輯一致。當 $m=3$ 時，時間複雜度約為 $O(2ⁿ)$；當 $m=4$ 時，則成長為雙層指數等級 $O(2^(2^(⋯2^n)))$ 。實際測試中，例如 $A(4,2)$ 的計算就可能需要數億次以上的操作，顯示其運算量極為龐大。
## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $n$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $m = 0$, $n = 3$ | $4$    | $4$        |
| 測試二   | $m = 1$, $n = 4$ | $6$        | $6$        |
| 測試三   | $m = 2$, $n = 3$ | $9$        | $9$        |
| 測試四   | $m = 3$, $n = 3$ | $61$       | $61$       |
| 測試五   | $m = 4$, $n = 0$ | 異常輸出 | 異常輸出 |

### 編譯與執行指令

```shell
請輸入 m 與 n ：2 3
A(2, 3) = 9
請輸入 m 與 n ：3 3
A(3, 3) = 61
請輸入 m 與 n ：4 0
A(4, 0) = 13
```

### 結論

1. $Ackermann$ 函數的遞迴結構清晰、易於理解，但極易導致記憶體堆疊爆炸。  
2. 使用堆疊模擬的非遞迴方法雖然能避免系統遞迴限制，但運算量仍指數級增加。

## 申論及開發報告

### 選擇遞迴方法的原因

在本程式中，使用遞迴來計算連加總和的主要原因如下：

1. 程式撰寫簡潔且易於理解  
   遞迴的寫法能用極少的程式碼呈現複雜的運算流程。每個條件分支都對應到特定數學規則，程式可讀性高、也方便後續除錯或驗證。相比非遞迴版本需要額外的堆疊模擬，遞迴的結構更自然，能讓程式邏輯一目了然。

2. 符合數學定義與邏輯直觀性
Ackermann 函數本身就是以遞迴方式定義的，因此使用遞迴函式來實作最能直接反映其數學結構。每一層呼叫都清楚對應到定義式中的三種情況：
   當 $m = 0$ 時，回傳 $n+1$ 。
   當 $n =0$ 時，計算 $A(m-1,1)$ 。
   其他情況下，呼叫 $A(m-1,A(m,n-1)) 。
   這樣的邏輯層次清晰、概念明確，讓整體函式架構與原始定義完全一致。

   --------------------------------------------------------------------------------------------------------------------------------------------------------------------

## 作業一(二) $Powerset$

## 解題說明
給定一個含有 $n$ 個元素的集合 $S$ ，其冪集 $powerset(S)$ 是所有子集合的集合；因此冪集的大小為 $2ⁿ$ 。例如 $S = {{a,b,c}}$ 時，
      $powerset(S)={{a},{b},{c},{a,b},{a,c},{b,c},{a,b,c}}$

### 解題策略
