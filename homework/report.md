# 41343149

## 作業一 $Ackermann's  Function$

## 解題說明

使用遞迴函式和非遞迴函式實現阿克曼函數

### $Ackermann$ 函數定義如下 :
| $A(m,n)$                 | 條件                  |
|------------------------|----------------------|
| $n + 1$                  | 當 m = 0             |
| $A(m-1, 1)$              | 當 n = 0             |
| $A(m-1, A(m, n-1))$      | 其他                 |

### 解題策略

1. 遞迴函式
   直接依照數學定義撰寫函式。每次呼叫自己時縮小問題規模，直到遇到最基本的情況 $m=0$ 。
2. 非遞迴函式
   使用堆疊模擬遞迴呼叫 每次將當前的 $m$ 推入堆疊，依條件進行回溯運算，直到堆疊清空為止

## 程式實作

遞迴函式：

```cpp
#include <iostream>
using namespace std;

// Ackermann 函式 (遞迴)
int Ackermann(int m, int n) {
    if (m == 0)
        return n + 1;
    else if (n == 0)
        return Ackermann(m - 1, 1);
    else
        return Ackermann(m - 1, Ackermann(m, n - 1));
}

int main() {
    int m, n;
    cout << "請輸入 m 與 n ：";
    while (cin >> m >> n) {
        cout << "A(" << m << ", " << n << ") = " << Ackermann(m, n) << endl;
        cout << "請輸入 m 與 n ：";
    }
    return 0;
}
```
非遞迴涵式 :

```cpp
#include <iostream>
using namespace std;

int AckermannLoop(int m, int n) {
    const int STACK_SIZE = 100000;
    int stack[STACK_SIZE];
    int top = 0;

    stack[top++] = m;

    while (top > 0) {
        m = stack[--top];

        if (m == 0) {
            n += 1;
        }
        else if (n == 0) {
            stack[top++] = m - 1;
            n = 1;
        }
        else {
            stack[top++] = m - 1;
            stack[top++] = m;
            n -= 1;
        }
    }
    return n;
}

int main() {
    int m, n;
    cout << "請輸入 m 與 n ：";
    while (cin >> m >> n) {
        cout << "A(" << m << ", " << n << ") = " << AckermannLoop(m, n) << endl;
        cout << "請輸入 m 與 n ：";
    }
    return 0;
}
```

## 效能分析
遞迴函式:
1. 時間複雜度：當 $m$ 與 $n$　的數值較小時(例如 $m=2,n=4$ )，整體遞迴深度仍然可控制在安全範圍內;但隨著輸入增大，遞迴呼叫會迅速堆疊，導致記憶體占用成倍成長。當 $m=0,1,2$ 時，空間複雜度大約為 $O(1)$ 、 $O(2)$ 、 $O(3)$ ;若m=3，則上升至約 $O(2ⁿ)$ ；而當 $m≥4$ 時，成長速度甚至超越指數級，極容易造成系統堆疊溢位。
2. 空間複雜度：對於較小的 $m$ 值(例如 $0、1、2、3$ )，可藉由簡單的遞迴公式推得其時間複雜度分別約為 $O(1)$ 、 $O(n)$ 、 $O(2ⁿ)$ 。但當 $m$ 提升至 4 以上時，函式的執行次數呈現爆炸性增長，其增長速率遠超過一般指數級，理論上屬於超指數等級的複雜度。

非遞迴函式:
1. 時間複雜度：在非遞迴版本中，雖然以陣列模擬呼叫堆疊能避免系統層級的遞迴限制，但所需的空間量仍隨m與n的增長急劇膨脹。當 $m=3$ 時，約為 $O(n)$ ;當m=4時，則提升為 $O(2ⁿ)$ ;而若 $m≥5$ ，其空間需求甚至可達 $O(2^(2^(⋯2^n)))$ 的多層次指數規模。
2. 空間複雜度：非遞迴實作的時間成本與遞迴版本相當，因為運算邏輯一致。當 $m=3$ 時，時間複雜度約為 $O(2ⁿ)$；當 $m=4$ 時，則成長為雙層指數等級 $O(2^(2^(⋯2^n)))$ 。實際測試中，例如 $A(4,2)$ 的計算就可能需要數億次以上的操作，顯示其運算量極為龐大。
## 測試與驗證

### 測試案例

| 測試案例 | 輸入參數 $n$ | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $m = 0$, $n = 3$ | $4$    | $4$        |
| 測試二   | $m = 1$, $n = 4$ | $6$        | $6$        |
| 測試三   | $m = 2$, $n = 3$ | $9$        | $9$        |
| 測試四   | $m = 3$, $n = 3$ | $61$       | $61$       |
| 測試五   | $m = 4$, $n = 0$ | 異常輸出 | 異常輸出 |

### 編譯與執行指令

```shell
g++ ackermann.cpp -o ackermann -std=c++17
./ackermann

請輸入 m 與 n ：2 3
A(2, 3) = 9
請輸入 m 與 n ：3 3
A(3, 3) = 61
請輸入 m 與 n ：4 0
A(4, 0) = 13
```

### 結論

1. $Ackermann$ 函數的遞迴結構清晰、易於理解，但極易導致記憶體堆疊爆炸。  
2. 使用堆疊模擬的非遞迴方法雖然能避免系統遞迴限制，但運算量仍指數級增加。

## 申論及開發報告

### 選擇遞迴方法的原因

在本程式中，使用遞迴來計算連加總和的主要原因如下：

1. 程式撰寫簡潔且易於理解  
   遞迴的寫法能用極少的程式碼呈現複雜的運算流程。每個條件分支都對應到特定數學規則，程式可讀性高、也方便後續除錯或驗證。相比非遞迴版本需要額外的堆疊模擬，遞迴的結構更自然，能讓程式邏輯一目了然。

2. 符合數學定義與邏輯直觀性
Ackermann 函數本身就是以遞迴方式定義的，因此使用遞迴函式來實作最能直接反映其數學結構。每一層呼叫都清楚對應到定義式中的三種情況：
   當 $m = 0$ 時，回傳 $n+1$ 。
   當 $n =0$ 時，計算 $A(m-1,1)$ 。
   其他情況下，呼叫 $A(m-1,A(m,n-1)) 。
   這樣的邏輯層次清晰、概念明確，讓整體函式架構與原始定義完全一致。

   --------------------------------------------------------------------------------------------------------------------------------------------------------------------

## 作業一(二) $Powerset$

## 解題說明
給定一個含有 $n$ 個元素的集合 $S$ ，其冪集 $powerset(S)$ 是所有子集合的集合；因此冪集的大小為 $2ⁿ$ 。例如 $S = {{a,b,c}}$ 時，
      $powerset(S)={(),(a),(b),(c),(a,b),(a,c),(b,c),(a,b,c)}$

### 解題策略
使用遞迴的方法，每次決定是否將當前元素加入子集合。當遞迴到最後一個元素時，即輸出目前的子集合。

## 程式實作

```cpp
#include <iostream>
#include <string>
using namespace std;

string elements[20];
string subset[20];
int n;

void powerSet(int index, int subsetSize) {
    if (index == n) {
        cout << "(";
        for (int i = 0; i < subsetSize; i++) {
            if (i) cout << ",";
            cout << subset[i];
        }
        cout << ")";
        cout << " ";
        return;
    }
    powerSet(index + 1, subsetSize);
    subset[subsetSize] = elements[index];
    powerSet(index + 1, subsetSize + 1);
}

int main() {
    cout << "請輸入元素個數 n：";
    cin >> n;

    cout << "請輸入 " << n << " 個元素：";
    for (int i = 0; i < n; i++)
        cin >> elements[i];

    cout << "Powerset 結果如下：" << endl;
    powerSet(0, 0);

    return 0;
}

```
## 效能分析
1. 共有 $2ⁿ$ 種子集合，每個子集合最多處理 $n$ 個元素，因此整體時間複雜度為 $O(n⋅2ⁿ)$ 。
2. 遞迴深度為 $n$ ，同時需保存目前的子集合，額外空間為 $O(n)$ 。若將所有結果保存起來，則需 $O(n⋅2ⁿ)$ 空間。

## 測試與驗證

### 測試案例
| 測資 | 輸入參數 $n$ , 元素 | 預期輸出 | 實際輸出 |
|----------|--------------|----------|----------|
| 測試一   | $n = 1$ , $a$ | $() (a)$       | $() (a)$       |
| 測試二   | $m = 2$ , $a b$ | $() (b) (a) (a,b)$  | $() (b) (a) (a,b)$       |
| 測試三   | $m = 3$ , $a b c$ | $() (c) (b) (b,c) (a) (a,c) (a,b) (a,b,c)$ | $() (c) (b) (b,c) (a) (a,c) (a,b) (a,b,c)$ |

### 編譯與執行指令

```shell
g++ powerset.cpp -o powerset -std=c++17
./powerset

請輸入元素個數 n：3
請輸入 3 個元素：a b c
Powerset 結果如下：
() (c) (b) (b,c) (a) (a,c) (a,b) (a,b,c)

```

### 結論
1. 遞迴能直觀地表達「選或不選」的過程，結構簡潔且易懂。
2. 遞迴法的優點是能以極少的程式碼完成極具層次感的運算過程，相較於迴圈或位元操作法，這種寫法更容易理解且結構清楚。

## 申論及開發報告

### 選擇遞迴的原因
1. 具良好的可擴充性與可讀性
   遞迴方法的結構固定且統一，若要修改輸出格式或增加其他運算條件（例如排序或篩選），只需在基底情況或分支部分稍作調整即可。這使得程式在實作上都更具彈性。
2. 邏輯結構清楚跟符合冪集定義
   冪集的生成就是一種二元選擇過程，每個元素都要判斷「是否被包含」。遞迴能自然地模擬這個決策流程：每一層遞迴代表一個元素的選擇狀態，當所有元素都被處理後，就形成一個完整的子集合。
3. 缺點跟限制
   由於冪集的結果數量為 $2ⁿ$ ，當輸入集合過大時，遞迴次數與輸出量都會急速增加，可能導致執行時間變長或記憶體使用量上升。
